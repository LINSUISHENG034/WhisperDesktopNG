# **行动计划E：终局之战 \- 统一与对齐**

## **1\. 背景与当前状态**

我们已通过行动计划D取得了决定性进展，将问题范围缩小至两个高度具体的嫌疑点：

1. **方法版本混乱**：项目中存在多个transcribe方法实现，导致调用路径进入了未预期的“幽灵版本”。  
2. **参数/环境不匹配**：我们的程序在CPU模式下运行，且关键参数（如Beam Search等）可能与成功的“黄金标准”不一致。

我们已从探索阶段，全面转入最后的攻坚修复阶段。

## **2\. 任务E的主要目标**

通过强制统一代码路径和精确对齐核心参数，**根除导致n\_segments=0的最后障碍，并成功输出转录文本**。

## **3\. 关键任务分解**

| 任务 ID | 关键任务 | 状态 |
| :---- | :---- | :---- |
| **E.1** | **根除“幽灵版本”（强制路径统一）** | ⬜ 未开始 |
| **E.2** | **参数与环境的精确对齐** | ⬜ 未开始 |
| **E.3** | **最终功能验证** | ⬜ 未开始 |

### **任务E.1详解：根除“幽灵版本”（强制路径统一）**

* **目标**：利用编译器，强制性地暴露并修正所有对旧版本transcribe方法的调用，确保全项目只存在一个唯一的、我们正在开发的实现。  
* **战术**：“焦土”编译法。这是一种短期内极具破坏性，但效率最高的重构方法。  
* **步骤**：  
  1. 在CWhisperEngine.h或相关的头文件中，找到所有transcribe方法的声明。  
  2. **将您不希望被调用的旧版本，全部重命名**。例如，将其重命名为 transcribe\_DEPRECATED\_1。  
  3. **只保留一个您希望被调用的、最新的transcribe方法**。  
  4. **执行一次完整的“Rebuild Solution”**。此时，编译器会因为找不到那些旧的\_DEPRECATED\_方法，在每一个调用点都生成一个编译错误。  
  5. 根据编译器的错误列表，逐一找到这些调用点，并将它们全部修改为调用您唯一保留的那个新方法。  
* **验收标准**：整个解决方案能够无错误地重新编译，并且我们100%确定，任何对转录功能的调用都会命中我们唯一指定的新方法。

### **任务E.2详解：参数与环境的精确对齐**

* **目标**：确保我们最终喂给whisper\_full\_with\_state的参数，在每一个细节上都与“黄金标准”中的成功案例保持一致。  
* **步骤**：  
  1. **激活参数日志**：在**任务E.1**确保了正确的代码路径后，我们之前添加的、用于打印whisper\_full\_params所有字段的详细日志代码，现在应该可以被执行了。  
  2. **逐一比对并修正**：运行我们的main.exe，将打印出的参数与您在“黄金标准”main\_golden.exe中记录的参数进行逐一、严格的对比。修正所有不一致的地方，特别是：  
     * n\_threads  
     * beam\_search.beam\_size  
     * beam\_search.best\_of  
     * task (确保是 transcribe)  
     * print\_timestamps  
  3. **对齐GPU/CPU环境**：在whisper\_context\_params的初始化阶段，找到设置use\_gpu的地方，并**暂时强制将其设置为true**，使我们的测试环境与“黄金标准”完全对齐。我们需要验证在GPU模式下功能是否恢复。

### **任务E.3详解：最终功能验证**

* **目标**：在完成路径统一和参数对齐后，进行最终的功能验证。  
* **步骤**：  
  1. 清理并重新编译整个解决方案。  
  2. 以Debug模式运行main.exe。  
  3. 观察控制台输出。

## **4\. 任务E的验收标准**

**唯一且明确的最终标准**：

**运行我们修复后的 main.exe 处理 jfk.wav 文件，能够在控制台打印出与“黄金标准”程序几乎完全相同的、正确的转录文本。**